Linkwatch: Design Doc

## 1. API Design & Endpoints

### URL Canonicalization

To ensure that semantically identical URLs are treated as a single target, the following canonicalization rules are applied in order upon registration:

- **Scheme & Host to Lowercase**: The scheme (http, https) and the host (Example.COM) are converted to lowercase.
- **Strip Default Ports**: Default ports (:80 for http, :443 for https) are removed. Custom ports are preserved.
- **Remove Fragments**: The URL fragment (#...) is removed entirely.
- **Trim Trailing Slash**: A trailing slash (/) is removed, unless the path is empty (i.e., it's the root like http://example.com).

**Example**: `HTTPS://Example.com:443/path/?a=1#section` becomes `https://example.com/path?a=1`.

### Cursor Pagination (GET /v1/targets)

To provide stable and efficient pagination, we use a cursor-based approach instead of traditional offset pagination.

- **Ordering**: Targets are sorted deterministically by `(created_at, id)`. This composite key prevents issues with items that have identical creation timestamps.
- **Page Token**: The `next_page_token` is an opaque string generated by Base64-encoding a JSON object containing the `created_at` timestamp and `id` of the last item in the current result set.
- **Querying**: When a request includes a `page_token`, it is decoded, and the database query uses a WHERE clause to fetch the next page: `WHERE (created_at, id) > ('2025-08-17T12:34:56Z', 't_123')`.

### Idempotency (POST /v1/targets)

Idempotency is handled at two levels, with Idempotency-Key taking precedence:

1. **Canonical URL**: If a request is made to create a target with a URL that canonicalizes to an existing one, the system returns the existing target with a `200 OK` status. A UNIQUE constraint on the `canonical_url` column in the database enforces this.

2. **Idempotency-Key Header**: To handle network retries that could create duplicate records from identical requests, we use a dedicated `idempotency_keys` table.

**Flow**:
- On a POST request with an Idempotency-Key, the server first checks if this key exists in the `idempotency_keys` table.
- If the key exists, the server immediately returns the previously created resource and a `200 OK` status.
- If not, the server proceeds with target creation within a database transaction. It inserts the new target and the idempotency key into their respective tables. If either step fails, the transaction is rolled back.

## 2. Database Schema (SQLite)

**Note**: Only SQLite is currently supported using the pure Go `modernc.org/sqlite` driver. PostgreSQL support is planned but not implemented.

```sql
-- Stores the URLs to be monitored
CREATE TABLE targets (
    id            TEXT PRIMARY KEY,         -- e.g., 't_' + base62(uuid)
    url           TEXT NOT NULL,            -- The original URL provided by the user
    canonical_url TEXT NOT NULL UNIQUE,     -- The canonical form of the URL for deduplication
    host          TEXT NOT NULL,            -- Extracted host for filtering and per-host limits
    created_at    TEXT NOT NULL             -- RFC3339Nano format for SQLite
);

-- Index for efficient pagination and host filtering
CREATE INDEX idx_targets_created_at_id ON targets (created_at, id);
CREATE INDEX idx_targets_host ON targets (host);

-- Stores the results of each check
CREATE TABLE check_results (
    id           TEXT PRIMARY KEY,
    target_id    TEXT NOT NULL,
    checked_at   TEXT NOT NULL,             -- RFC3339Nano format for SQLite
    status_code  INTEGER,                   -- Null if a network error occurred before getting a response
    latency_ms   INTEGER NOT NULL,
    error        TEXT,                      -- Null on success
    FOREIGN KEY(target_id) REFERENCES targets(id)
);

-- Index for fetching recent results for a target
CREATE INDEX idx_check_results_target_id_checked_at ON check_results (target_id, checked_at DESC);

-- Stores idempotency keys to prevent duplicate resource creation
CREATE TABLE idempotency_keys (
    key          TEXT PRIMARY KEY,          -- The Idempotency-Key from the HTTP header
    target_id    TEXT NOT NULL,
    created_at   TEXT NOT NULL,             -- RFC3339Nano format for SQLite
    FOREIGN KEY(target_id) REFERENCES targets(id)
);
```

## 3. Background Checker Architecture

### Components

- **Scheduler**: A central `time.Ticker` fires every `CHECK_INTERVAL` (e.g., 15s).
- **Job Dispatcher**: On each tick, the scheduler queries the database for all active targets and sends them as jobs into a buffered channel. This decouples scheduling from execution.
- **Worker Pool**: A fixed number of worker goroutines (`MAX_CONCURRENCY`, e.g., 8) read jobs from the channel. This caps the total number of concurrent checks across the entire system.
- **Per-Host Limiter**: Before a worker executes a check, it must acquire a lock specific to the target's host. This is implemented using a `map[string]struct{}` with a `sync.Mutex` for thread safety.

### Flow

1. To check `example.com`, a worker attempts to acquire the host lock.
2. If successful, it proceeds with the check. If not, the job is skipped for this cycle.
3. After the check (including retries) is complete, it releases the lock.

### Retries

On a 5xx status code or a network/timeout error, the worker retries up to 2 times with exponential backoff (200ms, 400ms). 4xx errors are not retried.

## 4. Testing Strategy

- **URL validation & canonicalization**: Tests all canonicalization rules and edge cases
- **Create idempotency**: Tests both Idempotency-Key and canonical URL deduplication
- **Cursor pagination**: Tests stable ordering and no skips/duplicates
- **Worker concurrency cap**: Tests MAX_CONCURRENCY enforcement
- **Per-host serialization**: Tests that only one check per host runs concurrently
- **Retry/backoff semantics**: Tests exponential backoff and retry limits
- **Database operations**: Tests all CRUD operations with real SQLite database
- **Error handling**: Tests graceful handling of network errors, timeouts, and invalid inputs

Tests use `httptest` for deterministic HTTP testing and avoid external network dependencies.

## 5. Operational Considerations

### Graceful Shutdown

Upon receiving a SIGTERM signal, the service:

1. Stops the scheduler's `time.Ticker` to prevent new jobs from being dispatched
2. Stops accepting new HTTP requests
3. Waits for all active worker goroutines to finish their current jobs, up to the `SHUTDOWN_GRACE` timeout (e.g., 10s)
4. Closes the database connection and shuts down

### Configuration

The service is configured via environment variables with sensible defaults:

- `CHECK_INTERVAL`: 15s
- `MAX_CONCURRENCY`: 8
- `HTTP_TIMEOUT`: 5s
- `SHUTDOWN_GRACE`: 10s
- `HTTP_PORT`: 8080
- `DATABASE_DRIVER`: sqlite (only supported option)
- `DATABASE_URL`: linkwatch.db

### Logging

Handles possible errors at nearly every step of each function.

## 6. Edge Cases

### Addressed Edge Cases

- **Thundering Herd on Startup**: When the service starts, it immediately schedules checks for all targets. With many targets, this could cause a spike in load.
- **Per-Host Limiter Memory**: The map for the per-host limiter grows indefinitely as new hosts are added.
- **Network Failures**: Robust retry logic with exponential backoff handles transient network issues.
- **Invalid URLs**: Comprehensive URL validation and canonicalization prevents malformed URLs from being stored.